{"0": {
    "doc": "Mysql boolean vs tinyint",
    "title": "배경",
    "content": "MySQL에서 boolean으로 컬럼을 생성했을 때 Dbeaver에서 생성해주는 테이블 생성 DDL에는 Tinyint로 찍히는 걸 발견했습니다. 이 현상의 원인에 대해 알아보겠습니다. ",
    "url": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/#%EB%B0%B0%EA%B2%BD",
    
    "relUrl": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/#배경"
  },"1": {
    "doc": "Mysql boolean vs tinyint",
    "title": "원인",
    "content": "Mysql 내부에는 boolean 타입이 존재하지 않습니다. boolean = tinyint(1)의 동의어로, boolean으로 선언한 컬럼이 tinyint로 저장되는 것은 이 때문입니다. boolean은 인터페이스 상에서만 존재하며, 컬럼 타입에 대한 사용자의 의도를 더 잘 드러내기 위해 사용됩니다. ",
    "url": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/#%EC%9B%90%EC%9D%B8",
    
    "relUrl": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/#원인"
  },"2": {
    "doc": "Mysql boolean vs tinyint",
    "title": "tinyint",
    "content": "Mysql의 tinyint는 1바이트 값으로 -128 ~ 127 사이의 값을 저장할 수 있습니다 (UNSIGNED의 경우 0 ~ 255). 관례적으로 boolean 값을 나타낼 때 tinyint(1)라는 표현을 사용하는데, 괄호 안의 숫자는 사이즈와 관련이 없고 표시 폭을 나타내는 값입니다. 이 역시 현재는 deprecated 된 개념으로 큰 의미는 없습니다. reference . https://dev.mysql.com/doc/refman/8.0/en/numeric-type-syntax.html https://stackoverflow.com/questions/11167793/boolean-or-tinyint-confusion . ",
    "url": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/#tinyint",
    
    "relUrl": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/#tinyint"
  },"3": {
    "doc": "Mysql boolean vs tinyint",
    "title": "Mysql boolean vs tinyint",
    "content": " ",
    "url": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/",
    
    "relUrl": "/docs/anna/2025/11/08/MySQL%20boolean%20vs%20tinyint/"
  },"4": {
    "doc": "Nest.js forRoot & forRootAsync",
    "title": "Nest.js forRoot & forRootAsync",
    "content": "forRoot와 forRootAsync는 모두 모듈 초기화 시 필요한 옵션을 설정하는 함수입니다. forRootAsync는 옵션을 만드는 useFactory 함수를 async로 동작하도록 설정할 수 있습니다. 또는, 다른 의존성이 준비된 뒤에 초기화를 해야 하는 경우에도 사용됩니다. ex) 데이터베이스 초기화 . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 . | // forRoot - 하드코딩된 설정 TypeOrmModule.forRoot({ type: 'mysql', host: 'localhost', port: 3306, username: 'root', password: 'password123', }) // forRootAsync - 동적으로 설정 가져오기 TypeOrmModule.forRootAsync({ inject: [ConfigService], useFactory: (configService: ConfigService) =&gt; ({ type: 'mysql', host: configService.get('DB_HOST'), port: configService.get('DB_PORT'), username: configService.get('DB_USER'), password: configService.get('DB_PASS'), }) }) . | . | forRoot는 하드코딩된 옵션 객체를 그대로 넘겨줍니다. | forRootAsync는 옵션을 설정하기 위한 의존성인 ConfigService와, 옵션을 생성하는 팩토리 함수를 함께 넘겨줍니다. forRootAsync 함수를 사용해야 환경에 따라 다른 의존성을 사용할 수 있습니다. | useFactory 함수가 async가 아닐 때도 forRootAsync가 사용되는 이유는 inject 옵션을 통해 옵션을 가져오기 위해 필요한 configService와 같은 타 의존성을 주입할 수 있기 때문입니다. | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 . | import { readFile } from 'fs/promises'; TypeOrmModule.forRootAsync({ inject: [ConfigService], useFactory: async (configService: ConfigService) =&gt; { // SSL 인증서 파일을 비동기로 읽기 const sslCert = await readFile( configService.get('DB_SSL_CERT_PATH'), 'utf-8' ); return { type: 'mysql', host: configService.get('DB_HOST'), port: configService.get('DB_PORT'), username: configService.get('DB_USER'), password: configService.get('DB_PASS'), ssl: { ca: sslCert, // 파일에서 읽어온 인증서 }, }; } }) . | . | 파일을 읽는 비동기 작업이 필요한 경우 이렇게 useFactory에 async 키워드를 붙여 사용할 수 있습니다. 이렇게 하면 NestJS가 파일 읽기가 완료될 때까지 기다린 후 모듈을 초기화하므로, SSL 인증서가 제대로 로드된 상태로 DB 연결을 시작할 수 있습니다. | . reference : https://docs.nestjs.com/graphql/quick-start#async-configuration . ",
    "url": "/docs/anna/2025/11/23/Nest.js%20forRoot%20&%20forRootAsync/",
    
    "relUrl": "/docs/anna/2025/11/23/Nest.js%20forRoot%20&%20forRootAsync/"
  },"5": {
    "doc": "Bastion Server 이해하기",
    "title": "Bastion Server (베스천서버)",
    "content": "베스천서버는 흔히 점프서버라 말하며, 점프 호스트, 점프 박스 등으로 이야기하곤 한다. 점프서버는 두 개 이상 네트워크 사이에 중간 지역으로 존재하며 보안을 위해 거쳐야하는 보안 게이트의 개념이다. 점프서버는 보통 외부에서 함부로 접근하지 못하도록 접근을 제한하고 보안을 향상시키는데 사용된다. 주로 AWS에서 SSM(AWS Systems Manager)에서 다루어진다. VPC 내에 모든 리소스는 서로 접근 가능하지만 외부에서 ssh로 private subnet 리소스에 대한 직접 접근은 불가능 하다. flowchart LR A[Client] subgraph Public direction RL B[Public Server] end subgraph Private BA[Private Server1] BB[Private Server2] end subgraph VPC subgraph JumpServer[\"JumpServer (Public)\"] C[Bastion Server] end JumpServer Private end A--점프호스트 경유--&gt;JumpServer--접근 가능--&gt;Private A--직접 연결--&gt;B--접근 불가--xPrivate . 위 예시처럼 직접 접근하는 서버의 경우에는 VPC 내 private에는 접근할 수 없다. 하지만 점프호스트를 경유하게 된다면 베스쳔서버 접근 한다. VPC 내 리소스는 서로 공유가 가능기 때문에 베스천 서버는 해당 VPC내 Private 서버에 접근할 수 있고, 점프호스트를 통해 내부 서브넷으로 접근 할 수 있다. 대규모 프로젝트에서 주로 활용되며 보안상 접근을 제한하고 분리할 때 사용된다. ",
    "url": "/docs/kimson/2025/11/25/bastion-server-study/#bastion-server-%EB%B2%A0%EC%8A%A4%EC%B2%9C%EC%84%9C%EB%B2%84",
    
    "relUrl": "/docs/kimson/2025/11/25/bastion-server-study/#bastion-server-베스천서버"
  },"6": {
    "doc": "Bastion Server 이해하기",
    "title": "베스천 서버 운용",
    "content": "베스천 서버 정보가 제공되면 이용은 간단하다. MobaXTerm이나 Putty, Xshell 등으로 점프 호스트를 입력하고 연결하고자 하는 내부 private subnet 정보를 입력해 연결을 자동화 해 둘 수 있다. ",
    "url": "/docs/kimson/2025/11/25/bastion-server-study/#%EB%B2%A0%EC%8A%A4%EC%B2%9C-%EC%84%9C%EB%B2%84-%EC%9A%B4%EC%9A%A9",
    
    "relUrl": "/docs/kimson/2025/11/25/bastion-server-study/#베스천-서버-운용"
  },"7": {
    "doc": "Bastion Server 이해하기",
    "title": "프록시 서버와 다른 점",
    "content": "베스쳔 서버를 이해하는데 프록시와 자주 혼동된다. 프록시의 경우 주로 HTTP/HTTPS 프래픽을 중계해주는 역할을 한다. 특히나 “대리”로 요청을 처리한다는 게 주요 핵심 개념이다. 목적은 보안, 캐싱, 속도 향상, 차단, 필터링, 로드 밸런싱 등이며, 정적 리소스를 캐싱해서 속도 향상하는데 주로 사용된다. 대표적으로 리버스 프록시와 포워드 프록시가 있는데, 리버스의 경우 서버 앞단에서 요청을 분배하며 로드밸런싱에 주로 사용되며, 내부 서버가 직접 서비스 하지 않고, 리버스 프록시를 거쳐 응답하기 때문에 내부망의 IP 노출되지 않아 해킹을 부터 안전하기 위해 사용되기도 한다. 포워드의 경우 내부 직원 인터넷 요청을 필터링하는데 사용되며 클라이언트 앞단에서 요청을 받아 특정 사이트 접근 제한 등에 사용된다. 일종의 방화벽과 같은 개념이라 보면 된다. 베스쳔 서버는 프록시와 달리 내부망의 리소스 접근을 차단하는 방화벽 호스트의 성격이 강하다. 📅 작성일: 2025-11-25 ✍️ 작성자: 김경남 . ",
    "url": "/docs/kimson/2025/11/25/bastion-server-study/#%ED%94%84%EB%A1%9D%EC%8B%9C-%EC%84%9C%EB%B2%84%EC%99%80-%EB%8B%A4%EB%A5%B8-%EC%A0%90",
    
    "relUrl": "/docs/kimson/2025/11/25/bastion-server-study/#프록시-서버와-다른-점"
  },"8": {
    "doc": "Bastion Server 이해하기",
    "title": "Bastion Server 이해하기",
    "content": " ",
    "url": "/docs/kimson/2025/11/25/bastion-server-study/",
    
    "relUrl": "/docs/kimson/2025/11/25/bastion-server-study/"
  },"9": {
    "doc": "서비스 운영에 필요한 서버 스펙 정의",
    "title": "서비스 운영에 필요한 서버 스펙 정의",
    "content": " ",
    "url": "/docs/kimson/2025/11/06/calculate-traffic/",
    
    "relUrl": "/docs/kimson/2025/11/06/calculate-traffic/"
  },"10": {
    "doc": "서비스 운영에 필요한 서버 스펙 정의",
    "title": "서비스 수준 (Service Level)",
    "content": "서비스 수준에는 크게 세가지 용어로 설명한다. | 서비스 수준 목표(ServiceLevel Objectives, SLO): 시스템에서 기대되는 가용성을 설정한 목표. | 서비스 수준 지표(Service Level Indicators, SLI): 시스템의 가용성을 파악하기 위한 핵심 측정치와 지표. | 서비스 수준 계약(Service-Level agreements, SLA): 시스템이 SLO를 충족하지 못할 경우 발생하는 상황과 합의된 내용을 설명하는 법적 계약. | . 트래픽 산정을 다루기 위해 SLO 개념을 주로 다룹니다. 서비스 수준의 종류에 대한 비교와 상세 설명은 여기를 참조해주세요. ",
    "url": "/docs/kimson/2025/11/06/calculate-traffic/#%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%88%98%EC%A4%80-service-level",
    
    "relUrl": "/docs/kimson/2025/11/06/calculate-traffic/#서비스-수준-service-level"
  },"11": {
    "doc": "서비스 운영에 필요한 서버 스펙 정의",
    "title": "스펙 산정의 과정",
    "content": ". | SLO 정의(성능 목표) . | 가용성: 예) 99.9% | . | 수요 모델링(Workload) . | 사용자 규모: DAU/WAU/MAU, 피크배율(평균 대비 최대 트래픽 배수) | 사용 패턴: 세션 길이, 페이지/분, API 호출/페이지, Think time | 트래픽 조합: GET/POST 비율, 실시간 여부, 배치 작업 유무 | . | 리소스 모델링(자원/비용) . | CPU, 메모리, 네트워크(대역폭/egress), 디스크(용량/IOPS/Throughput), DB/캐시 | 한 요청당 자원 사용량(서비스 시간, 쿼리 수, 바이트) | . | 검증(Load Test/관측) | 가설 수치로 부하 테스트 → 관측치로 모델 보정 → 여유분(헤드룸) 확정 | . 모델을 먼저 만들고, 실측으로 보정하는 편이 추정만 하는 것보다 좋다고 한다. ",
    "url": "/docs/kimson/2025/11/06/calculate-traffic/#%EC%8A%A4%ED%8E%99-%EC%82%B0%EC%A0%95%EC%9D%98-%EA%B3%BC%EC%A0%95",
    
    "relUrl": "/docs/kimson/2025/11/06/calculate-traffic/#스펙-산정의-과정"
  },"12": {
    "doc": "서비스 운영에 필요한 서버 스펙 정의",
    "title": "핵심 공식",
    "content": ". | QPS/RPS(초당 요청 수) RPS = 동시활성 사용자 x 사용자당 RPS 사용자당 RPS = (페이지/분 x 페이지당 API콜 수) / 60 | 대역폭(Throughput) 초당 전송량(바이트/초) = RPS x 평균응답크기(바이트) 원본 서버 기준 트래픽 = 전체 트래픽 x (1 - 캐시적중률) | Little’s Law 동시요청수 L = λ(도착률 RPS) × W(평균 응답시간) 예) RPS=200, 평균=0.2초 → L=40개 동시 처리 필요 | CPU 활용도(단일 코어 근사) U = λ × S (S=평균 서비스시간/요청의 CPU점유 시간) 목표 활용도(ρ)를 0.6~0.7로 제한 → 필요 코어수 ≈ (λ × S) / ρ | DB IOPS DB RPS = App RPS x 요청당 쿼리수 x (1 - 캐시히트) 스토리지 IOPS/Throughput은 엔진, 인덱스, 트랜잭션 크기에 따라 상이 → 부하테스트로 보정 | 저장소 용량(로그/이벤트) 일간 데이터량 = 이벤트 수/일 x 평균 바이트 필요 용량 = 일간 x 보관일수 x (1 + 압축여유) | . ",
    "url": "/docs/kimson/2025/11/06/calculate-traffic/#%ED%95%B5%EC%8B%AC-%EA%B3%B5%EC%8B%9D",
    
    "relUrl": "/docs/kimson/2025/11/06/calculate-traffic/#핵심-공식"
  },"13": {
    "doc": "서비스 운영에 필요한 서버 스펙 정의",
    "title": "계산 예시와 설명",
    "content": "문제를 가정하고 더 쉬운 풀이로 계산해나간다. | 동시에 쓰는 사람 수(피크 동시 사용자) . | 어디서: 구글 애널리틱스 동시 접속, 서버 로그(시간대별 요청), 없다면 합리적 추정(=평균의 3~10배) | 뜻: 가장 바쁠 때 한순간에 놀러 오는 사용자 수 | . | 한 사람이 1분에 몇 화면 보나(페이지/분) . | 뜻: 사용자이 1분에 몇개의 컨텐츠를 보는지 | 어디서: 프론트 로그/GA4, 없으면 1~3으로 가정 | . | 화면 하나에 API를 몇 번 요청하는지(API/화면) . | 뜻: 컨텐츠 하나 볼 때 서버로 몇 번 요청하는지 | 어디서: 네트워크 탭/백엔드 라우트 카운트(대개 1~5) | . | 응답 크기(바이트) . | 뜻: 서버에서 응답하는 데이터 크기 | 어디서: 서버 로그 response size 평균 (예: 10~50KB) | . | 목표 속도(응답시간) . | 뜻: 사용자 한 명을 평균 몇 초 만에 처리할지 (예: 평균 0.2초) | 어디서: APM/로그, 없으면 목표로 정함 (예: 0.1 ~ 0.3초) | . | 캐시 유무(적중률) . | 뜻: 자주 요청하는 건 미리 준비해서 바로 제공(정적/GET 캐시 적중률) | 어디서: CDN/프록시 통계(없으면 0~60% 가정) | . | 요청 하나에 DB를 몇 번 쿼리 요청하는지(쿼리/요청) (QPS) . | 뜻: 서버가 DB에 몇 번 조회 하는가 | 어디서: 쿼리 로깅/ORM 미들웨어 (예: 대개 1~5) | . | . 예시 계산 . 핵심 공식 일부를 사용해 모의로 트래픽을 계산한다. | 초당 요청 수(RPS): 동시 사용자 x 한 사람의 초당 요청 수 . | 한 사람 초당 요청 수: (페이지/분 x API/페이지) / 60 | 예) 페이지/분 2, API/페이지 2 → 4/60 = 0.0667 | 동시 50명 → RPS = 50 x 0.0667 = 약 3.33RPS | 즉, 초당 3.33개의 요청이 발생 | . | 동시 처리 요청 수: RPS x 평균 응답 시간(초) . | 예) 3.33 x 0.2초 = 0.666 (= 대략 0.67개) | 뜻: 서버가 동시에 붙잡고 있는 사용자 수 | . | 초당 데이터 양(대역폭): RPS x 평균 응답 크기 . | 예) 3.33 x 15KB = 약 50KB/s (= 약 0.4Mb/s) | . | 초당 DB 일(쿼리 수): RPS x (쿼리/요청) x (1 - 캐시 히트) . | 예) 쿼리/요청 2, 캐시 없음 → 3.33 x 2 = 6.66QPS | . | . 여기까지 계산하면 “얼마나 바쁜지” 눈에 보인다. 초당 3.33명이 사용하고, 동시에 1명을 처리중이며, 초당 50KB데이터가 응답되며, DB는 초당 6~7번 일한다. 서버 스펙 산정 . 서버(계산대), DB(창고 직원), 캐시/CDN(진열대)으로 나눈다. | 애플리케이션 서버(계산대) . | vCPU(계산대 수): 대략 동시요청 수 x 2배면 초보자 사용에 충분 이유는 스파이크, GC 등 버퍼가 필요하기 때문 . | 예) 동시 요청 = 약 1 → 2 vCPU 추천(최소 2개 = N + 1) | . | 메모리: 앱 기본 메모리 + (동시요청 x 요청당 임시 메모리 5~20MB) + 여유 30% . | 예) 기본 300MB + (1 x 10MB) → 1~2GB면 충분 | . | 네트워크: 대역폭 계산값 x 1.5 ~ 2배 . | 예) 50KB/s x 2 = 100KB/s 여유(클라우드 기본으로 충분) | . | . | 데이터베이스(창고 직원) . | QPS 보고 작은 사양으로 시작 + 인덱스/쿼리 튜닝 . | 예) 6~7 QPS명 소형 인스턴스도 무난 | . | 중요: 느린 쿼리를 해결하면 서버 스펙보다 효과 큼 | . | 캐시/CDN(진열대) . | GET 결과 30~120초 캐시만 해도 RPS/DB부하 크게 감소 | 이미지/정적 리소스는 CDN 기본 | . | . 실무에서 산정에 필요한 데이터 모으는 팁 . | 프론트/게이트웨이 로그: 라우트별 호출 수와 응답 크기 평균 | 하루 중 가장 바쁜 시간 30분 뽑기 → 피크 동시 사용자 근사값 추출 | 네트워크 탭 한 화면당 호출 개수 (대략치 판별) | APM/로그로 평균 응답 시간 확인(목표치 없으면 0.2초로 산정) | ORM/DB 로그로 요청당 쿼리 수 평균 산정 | . ",
    "url": "/docs/kimson/2025/11/06/calculate-traffic/#%EA%B3%84%EC%82%B0-%EC%98%88%EC%8B%9C%EC%99%80-%EC%84%A4%EB%AA%85",
    
    "relUrl": "/docs/kimson/2025/11/06/calculate-traffic/#계산-예시와-설명"
  },"14": {
    "doc": "서비스 운영에 필요한 서버 스펙 정의",
    "title": "모의 계산",
    "content": "다음은 계산에 필요한 데이터 조건. | 동시 사용자: 50명 | 페이지/분 2, API/페이지 2 → 4/60 = 0.0667 | 평균 응답 0.2초, 평균 크기 15KB, QPS(쿼리/요청) 2 | . 계산 . | RPS = 50 x 0.0667 = 약 3.33(request/sec) | 동시요청 = 3.33 x 0.2 = 0.666 = 약 1 | 대역폭 = 3.33 x 15KB = 약 50KB/s | DB QPS = 3.33 x 2 = 6.66(query/sec) | . 스펙 제안 . | APP: 2 vCPU / 2GB x 2대 시작 | DB: 소형 + 모니터링 (느린 쿼리 튜닝) | CDN/캐시: 정적 필수, 목록/상세 GET 30~120초 캐시 | . ✅ 레퍼런스 . | 예상 트래픽 산정 | CPU vs vCPU | SLA,SLA,SLI 비교 | QPS, RPS 비교 | . 📅 작성일: 2025-11-06 03:18:24 ✍️ 작성자: 김경남 . ",
    "url": "/docs/kimson/2025/11/06/calculate-traffic/#%EB%AA%A8%EC%9D%98-%EA%B3%84%EC%82%B0",
    
    "relUrl": "/docs/kimson/2025/11/06/calculate-traffic/#모의-계산"
  },"15": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "🧠 (예시) NestJS 의존성 주입 원리 이해하기",
    "content": ". ",
    "url": "/docs/kimson/2025/11/03/example/#-%EC%98%88%EC%8B%9C-nestjs-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9B%90%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    
    "relUrl": "/docs/kimson/2025/11/03/example/#-예시-nestjs-의존성-주입-원리-이해하기"
  },"16": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "1️⃣ 어떤 주제로 공부했나요?",
    "content": "최근 NestJS로 프로젝트를 진행하면서 DI(Dependency Injection) 컨테이너 구조가 헷갈려서 의존성 주입의 원리와 실제 동작 방식을 정리해보았습니다. | NestJS의 DI가 어떻게 동작하는지 궁금했음 | Angular 기반 구조와의 유사점, 차이점이 있는지 확인하고 싶었음 | . ",
    "url": "/docs/kimson/2025/11/03/example/#1%EF%B8%8F%E2%83%A3-%EC%96%B4%EB%96%A4-%EC%A3%BC%EC%A0%9C%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%96%88%EB%82%98%EC%9A%94",
    
    "relUrl": "/docs/kimson/2025/11/03/example/#1️⃣-어떤-주제로-공부했나요"
  },"17": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "2️⃣ 스터디 과정 (어떤 방식으로 공부했는가)",
    "content": ". | NestJS 공식문서 및 DI 관련 챕터 정독 NestJS Dependency Injection 공식문서 | 인프런 NestJS 강의 참고 | 팀원과 DI가 필요한 실제 사례를 들어 설계 토의 | 예시 실습: @Injectable()과 ModuleRef를 이용해 커스텀 Provider 작성 | . ",
    "url": "/docs/kimson/2025/11/03/example/#2%EF%B8%8F%E2%83%A3-%EC%8A%A4%ED%84%B0%EB%94%94-%EA%B3%BC%EC%A0%95-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%96%88%EB%8A%94%EA%B0%80",
    
    "relUrl": "/docs/kimson/2025/11/03/example/#2️⃣-스터디-과정-어떤-방식으로-공부했는가"
  },"18": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "3️⃣ 알게 된 점",
    "content": ". | NestJS의 DI는 Angular에서 발전된 구조 사용 | 의존성 주입이 클래스 생성자 레벨에서 TypeScript의 타입 정보와 Reflect Metadata 기반으로 동작 | Provider 등록 시 Lazy Loading, Scope 변환 등 다양한 옵션 제공 | 복잡한 의존 관계를 효율적으로 관리할 수 있음 | . ",
    "url": "/docs/kimson/2025/11/03/example/#3%EF%B8%8F%E2%83%A3-%EC%95%8C%EA%B2%8C-%EB%90%9C-%EC%A0%90",
    
    "relUrl": "/docs/kimson/2025/11/03/example/#3️⃣-알게-된-점"
  },"19": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "4️⃣ 더 궁금한 점",
    "content": ". | Request 스코프 Provider의 주입 타이밍 및 라이프사이클 관리 | 커스텀 Provider 작성 시 내부적으로 어떤 Hook이 동작하는지 | DI 에러가 발생했을 때 디버깅 노하우 | . ",
    "url": "/docs/kimson/2025/11/03/example/#4%EF%B8%8F%E2%83%A3-%EB%8D%94-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%90",
    
    "relUrl": "/docs/kimson/2025/11/03/example/#4️⃣-더-궁금한-점"
  },"20": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "5️⃣ 결과적으로 느낀 점",
    "content": ". | DI를 제대로 이해하니 모듈화와 유지보수성이 높은 구조를 설계할 수 있을 것 같음 | NestJS의 내부 동작을 이해하는 데 도움이 되었음 | 다음 스터디에선 AOP 개념과 Interceptor를 연계해보고자 함 | . 📅 작성일: 2025-11-03 ✍️ 작성자: GPT5 . ",
    "url": "/docs/kimson/2025/11/03/example/#5%EF%B8%8F%E2%83%A3-%EA%B2%B0%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%8A%90%EB%82%80-%EC%A0%90",
    
    "relUrl": "/docs/kimson/2025/11/03/example/#5️⃣-결과적으로-느낀-점"
  },"21": {
    "doc": "(예시) NestJS 의존성 주입 원리 이해하기",
    "title": "(예시) NestJS 의존성 주입 원리 이해하기",
    "content": " ",
    "url": "/docs/kimson/2025/11/03/example/",
    
    "relUrl": "/docs/kimson/2025/11/03/example/"
  },"22": {
    "doc": "안나 스터디",
    "title": "안나 스터디",
    "content": "테스트 . ",
    "url": "/docs/anna/",
    
    "relUrl": "/docs/anna/"
  },"23": {
    "doc": "경남 스터디",
    "title": "경남 스터디",
    "content": "테스트 . ",
    "url": "/docs/kimson/",
    
    "relUrl": "/docs/kimson/"
  },"24": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "레디스 원자성 확보를 위한 분산락 처리",
    "content": "레디스는 노드와 유사하게 싱글 스레드로 동작한다. 단일 레디스 노드를 구축해 사용해도 동시성 문제는 발생하지 않는다. 따라서 리소스에 대해 값이 설정된 경우 다른 리소스 접근을 차단할 수 있다. 이를 잠금이라 표현하고, 이를 다음과 같이 명령을 사용해 재현할 수 있다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/"
  },"25": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "Lock(락)의 개념",
    "content": "“락을 회득한다”라는 말을 자주 사용하게 되는데, 공유 자원을 혼자 안전하게 사용하기 위해 다른 클라이언트가 접근하지 못하게 점유권을 빌리는 것을 말한다. 즉, 재고가 10일 경우, A와 B가 서로 수정하려 할 때 한 순간에 오직 하나의 클라이언트만 재고 수정 가능하게 만드는 장치를 락이라 한다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#lock%EB%9D%BD%EC%9D%98-%EA%B0%9C%EB%85%90",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#lock락의-개념"
  },"26": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "락 유무에 따른 시나리오",
    "content": "자원: stock:drink001 (현 재고: 10) . | clientA: 재고 +5 증가 예정 | clientB: 재고 -3 감소 예정 | 동시에 요청 발생 | . 만약 두 요청이 GET/SET 한다면? . 락 없는 경우 . | 1 2 3 4 . | # clientA 수정 시도 GET stock:drink001 # -&gt; 10 # 계산: 10 + 5 = 15 SET stock:drink001 15 . | . | 1 2 3 4 . | # clientB 수정 시도 (거의 동시 수행 가정하고 서로 GET한 시점이 같을 때) GET stock:drink001 # -&gt; 10 (clientA SET 전) # 계산: 10 - 3 = 7 SET stock:drink001 7 . | . 이 경우 최종 재고가 7이 되고, clientA의 작업이 완전 날아가버린다. 이를 경쟁 조건(Race Condition)이라한다. 이 때문에 공유 자원을 두고 안정하게 데이터를 사용하거나 수정하기 위해 락이 필요하다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%9D%BD-%EC%9C%A0%EB%AC%B4%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#락-유무에-따른-시나리오"
  },"27": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "락 획득(Acquire the lock)",
    "content": "레디스에서는 아래와 같이 표현 된다. | 1 . | SET lock:stock:drink001 &lt;UUID&gt; NX EX 10 . | . 이 한 줄이 “락 획득”이 된다. 락 획득의 조건은 다음과 같다. 락 획득 조건 . | NX: 락 키가 없을 때만 생성 | EX 10: 락은 10초 후 자동 제거 | «UUID»: 락 소유자를 식별하는 일종의 신분증 역할(인증 토큰 개념) | . 락 획득 성공 조건 . 누구든 먼저 이 명령을 성공하면 그 자원을 점유하는 상태가 된다. | 1 2 . | SET lock:stock:drink001 C1_UUID NX EX 10 # 성공 -&gt; clientA가 락을 획득 . | . | 1 2 . | SET lock:stock:drink001 C2_UUID NX EX 10 # 실패 -&gt; 해당 락키가 있기 때문에 접근 불가 . | . ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%9D%BD-%ED%9A%8D%EB%93%9Dacquire-the-lock",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#락-획득acquire-the-lock"
  },"28": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "락 획득 후 달라지는 점",
    "content": "clientA는 이제 다음처럼 안전하게 데이터 변경 가능 . | 1 2 3 4 . | # 현재 재고 GET stock:drink001 # 10 # 계산 SET stock:drink001 &lt;10 + n&gt; . | . 작업 이후 락을 풀어줘야 하는데 아래와 같이 락을 풀게 된다. | 1 . | DEL lock:stock:drink001 . | . 여기서 문제가 발생하는데 client가 요청할 때 동시성 문제로 인해 아래와 같은 시나리오라면 큰 문제가 발생할 수 있다. | clientA가 락 획득 | 어떤 타이밍에 clientB가 다시 락 획득 | clientA가 늦게 작업 된 경우 DEL 명령 | clientB의 락 해제 | . 위와 같은 시나리오는 “lock:” 키를 설정할 때 만료시간 보다 더 긴 작업이 있을 경우 충분히 발생할 수 있는 문제다. 때문에 단순히 DEL 명령으로 제거하면 안되고, 해당 lock키의 uuid 값이 유효한지 검증한 후 제거해야한다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%9D%BD-%ED%9A%8D%EB%93%9D-%ED%9B%84-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94-%EC%A0%90",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#락-획득-후-달라지는-점"
  },"29": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "레디스의 트랜젝션",
    "content": "레디스는 MySQL과 같은 SQL 계열의 DB와 달리 다른 의미의 트랜젝션을 수행한다. SQL의 트랜젝션과 같이 여러 개의 명령을 하나의 묶음으로 만들어 순서대로 실행하고, 명령 순서가 보장된다. 레디스에서 롤백 기능이 없고 SQL처럼 예외 발생 시 데이터를 되돌리는 기능이 없다. 일부 WATCH 기반의 낙관적 락에서는 예외이다. 때문에 원자성이 완벽하게 보장되지 않는 문제가 발생한다. 레디스에서 제공하는 트랜젝션은 3가지 명령이 있는데, MULTI, WATCH, EXEC이며, 3가지 명령을 조합해서 사용하더라도 락 획득 실패하거나 데이터 수정 실패 시 실패한 요청의 경우 모든 프로세스가 정지되는 현상이 발생한다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%A0%88%EB%94%94%EC%8A%A4%EC%9D%98-%ED%8A%B8%EB%9E%9C%EC%A0%9D%EC%85%98",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#레디스의-트랜젝션"
  },"30": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "레디스 원자적 작업",
    "content": "레디스에서는 lua 스크립트 실행을 지원한다. 위 설명했던 트랜젝션을 구현하는데 단점을 보완하여 lua 스크립트를 활용하면 훨씬 강력하고 안정한 트랜젝션을 구현할 수 있다. lua 스크립트는 레디스 내부에서 스크립트를 한 명령처럼 실행하기 때문에 “조건 확인 + 업데이터 + 삭제” 전체가 “불가분 원자적”이다. 락 해제, 재고감소와 같은 복잡한 로직에 필수적으로 사용된다. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 . | async function veryHeavyLogic() { const lockKey = \"lock:stock:drink001\"; const stockKey = \"stock:drink001\"; const lockUUID = nanoid(16); const calcValue = 5; await redis.eval(` local lockKey = KEY[1] local stockKey = KEY[2] local lockUUID = ARGV[1] local value = ARGV[2] if redis.call('GET', lockKey) == lockUUID then redis.call('SET', stockKey, value) redis.call('DET', lockKey) end `, lockKey, stockKey, 2, lockUUID, calcValue); } . | . 위와 같이 lua 스크립트를 활용하면 스크립트 한 묶음을 하나의 명령처럼 처리하기 때문에 안전하게 원자적으로 데이터를 점유하고 수정가능하게 된다. 다른 클라이언트와 동시에 수정하더라도 다른 클라이언트의 요청은 실패하고 안전하게 데이터 수정이 용이하게 된다. 실패한 요청은 큐를 이용해 재시도하거나 버리는 식의 처리가 가능해진다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%A0%88%EB%94%94%EC%8A%A4-%EC%9B%90%EC%9E%90%EC%A0%81-%EC%9E%91%EC%97%85",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#레디스-원자적-작업"
  },"31": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "마무리",
    "content": "레디스를 단순히 Key-Value 쌍의 인메모리 DB로 생각하고 간단한 세션 관리나 소켓과 유사하게 브로드캐스트하는 용도로만 생각했지만, 트랜젝션 관리와 lua 스크립트 결합을 통해 동시성에 관한 기술적인 이해도를 높인 좋은 기회였다. 오늘 다룬 내용은 분산락에 대한 개념이자, 레디스가 제공하는 분산락(레드락)의 한계를 lua 스크립트로 보완하는 내용을 주로 다룬다. 앞으로 락에 관한 키워드로 낙관락, 비관락을 이해하고 더 공부해야겠다는 생각이 든다. ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%A7%88%EB%AC%B4%EB%A6%AC",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#마무리"
  },"32": {
    "doc": "레디스 원자성 확보를 위한 분산락 처리",
    "title": "레퍼런스",
    "content": ". | 레디스가 제공하는 분산락(RedLock) | node.js 환경에서 redis 분산락 구현 | . 📅 작성일: 2025-11-16 11:45:03 ✍️ 작성자: 김경남 . ",
    "url": "/docs/kimson/2025/11/16/redis-transaction/#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4",
    
    "relUrl": "/docs/kimson/2025/11/16/redis-transaction/#레퍼런스"
  },"33": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "🧠 스터디 주제: (예: NestJS 의존성 주입 원리 이해하기)",
    "content": ". ",
    "url": "/template/template-study/#-%EC%8A%A4%ED%84%B0%EB%94%94-%EC%A3%BC%EC%A0%9C-%EC%98%88-nestjs-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85-%EC%9B%90%EB%A6%AC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0",
    
    "relUrl": "/template/template-study/#-스터디-주제-예-nestjs-의존성-주입-원리-이해하기"
  },"34": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "1️⃣ 어떤 주제로 공부했나요?",
    "content": ". | 주제 배경, 선택 이유 | 관련된 기술 스택 혹은 문제 상황 | . 예시: . 최근 NestJS로 프로젝트를 진행하면서 DI 컨테이너 구조가 헷갈려서 원리를 정리해봤어요. ",
    "url": "/template/template-study/#1%EF%B8%8F%E2%83%A3-%EC%96%B4%EB%96%A4-%EC%A3%BC%EC%A0%9C%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%96%88%EB%82%98%EC%9A%94",
    
    "relUrl": "/template/template-study/#1️⃣-어떤-주제로-공부했나요"
  },"35": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "2️⃣ 스터디 과정 (어떤 방식으로 공부했는가)",
    "content": ". | 문서, 영상, 공식 문서 링크 등 참고 자료 | 실습 코드나 실험 과정 | 팀원과 토의한 내용 | . 예시: . 공식 문서와 NestJS 소스 코드를 분석하면서 @Injectable()과 ModuleRef 동작 방식을 비교했습니다. ",
    "url": "/template/template-study/#2%EF%B8%8F%E2%83%A3-%EC%8A%A4%ED%84%B0%EB%94%94-%EA%B3%BC%EC%A0%95-%EC%96%B4%EB%96%A4-%EB%B0%A9%EC%8B%9D%EC%9C%BC%EB%A1%9C-%EA%B3%B5%EB%B6%80%ED%96%88%EB%8A%94%EA%B0%80",
    
    "relUrl": "/template/template-study/#2️⃣-스터디-과정-어떤-방식으로-공부했는가"
  },"36": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "3️⃣ 알게 된 점",
    "content": ". | 새롭게 이해한 개념, 깨달음 | 기존과 달랐던 점 | . 예시: . NestJS의 DI는 Angular에서 발전된 구조로, Provider 등록 시 Lazy Loading이 가능하다는 걸 알게 됐어요. ",
    "url": "/template/template-study/#3%EF%B8%8F%E2%83%A3-%EC%95%8C%EA%B2%8C-%EB%90%9C-%EC%A0%90",
    
    "relUrl": "/template/template-study/#3️⃣-알게-된-점"
  },"37": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "4️⃣ 더 궁금한 점",
    "content": ". | 추가로 파고들고 싶은 개념 | 아직 명확하지 않은 부분 | . 예시: . 스코프가 Request일 때 Provider 주입 타이밍이 어떻게 관리되는지 더 알고 싶어요. ",
    "url": "/template/template-study/#4%EF%B8%8F%E2%83%A3-%EB%8D%94-%EA%B6%81%EA%B8%88%ED%95%9C-%EC%A0%90",
    
    "relUrl": "/template/template-study/#4️⃣-더-궁금한-점"
  },"38": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "5️⃣ 결과적으로 느낀 점",
    "content": ". | 이번 스터디로 얻은 인사이트나 감정 | 다음 스터디 계획 | . 예시: . 단순히 “DI가 된다”가 아니라 내부 구조를 이해하니 아키텍처 설계에 자신감이 생겼어요. 다음엔 AOP 개념과 Interceptor를 이어서 공부해보려 합니다. 📅 작성일: 2025-11-03 ✍️ 작성자: @yourname . ",
    "url": "/template/template-study/#5%EF%B8%8F%E2%83%A3-%EA%B2%B0%EA%B3%BC%EC%A0%81%EC%9C%BC%EB%A1%9C-%EB%8A%90%EB%82%80-%EC%A0%90",
    
    "relUrl": "/template/template-study/#5️⃣-결과적으로-느낀-점"
  },"39": {
    "doc": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "title": "스터디 주제: _(예: NestJS 의존성 주입 원리 이해하기)_",
    "content": " ",
    "url": "/template/template-study/",
    
    "relUrl": "/template/template-study/"
  },"40": {
    "doc": "테스트 포스트",
    "title": "테스트 포스트",
    "content": "☘️ 우왕 . ",
    "url": "/docs/anna/2025/11/03/test/",
    
    "relUrl": "/docs/anna/2025/11/03/test/"
  },"41": {
    "doc": "🚀 로컬 개발 환경 설정 가이드",
    "title": "🚀 로컬 개발 환경 설정 가이드",
    "content": "# 🚀 로컬 개발 환경 설정 가이드 ## 필수 사항 로컬에서 Jekyll을 실행할 때 GitHub Pages와 동일하게 작동하려면 다음 명령어를 사용해야 합니다. ## 설치 ```bash # 1. Ruby 설치 확인 ruby --version # 2. Bundler 설치 (없는 경우) gem install bundler # 3. 의존성 설치 bundle install ``` ## 실행 방법 ### 올바른 실행 방법 (GitHub Pages와 동일) ```bash # 프로젝트 루트에서 실행 bundle exec jekyll serve --source docs --destination _site ``` 또는 더 간단하게: ```bash cd docs bundle exec jekyll serve ``` ### 서버 시작 후 브라우저에서 `http://localhost:4000` 또는 `http://127.0.0.1:4000`으로 접속하세요. ## 문제 해결 ### Remote Theme가 적용되지 않는 경우 1. **플러그인 확인** - `_config.yml`에 `jekyll-remote-theme`이 `plugins` 목록에 있는지 확인 - `bundle list | grep remote` 명령어로 플러그인 설치 확인 2. **네트워크 연결 확인** - Remote theme는 GitHub에서 테마를 다운로드해야 하므로 인터넷 연결이 필요합니다 - 방화벽이나 프록시 설정이 GitHub API 접근을 막고 있는지 확인 3. **캐시 삭제** ```bash rm -rf .jekyll-cache rm -rf _site bundle exec jekyll clean bundle exec jekyll serve --source docs ``` 4. **플러그인 재설치** ```bash bundle update jekyll-remote-theme bundle exec jekyll serve --source docs ``` ## 빌드 명령어 (GitHub Actions와 동일) ```bash bundle exec jekyll build -s docs -d _site ``` ## 추가 팁 - `--incremental` 옵션을 사용하면 변경된 파일만 재빌드하여 더 빠릅니다: ```bash bundle exec jekyll serve --source docs --incremental ``` - `--livereload` 옵션을 사용하면 파일 변경 시 자동으로 브라우저가 새로고침됩니다: ```bash bundle exec jekyll serve --source docs --livereload ``` ",
    "url": "/LOCAL_SETUP/",
    
    "relUrl": "/LOCAL_SETUP/"
  },"42": {
    "doc": "🌱 Study Archive",
    "title": "🌱 Study Archive",
    "content": "# 🌱 Study Archive > **공부는 나 혼자 하는 게 아니라, 서로의 생각을 엮는 과정이다.** > 이 공간은 각자 배운 것을 Markdown으로 기록하고, 서로의 관점을 공유하는 스터디 블로그입니다. --- ## 📚 스터디 목록 ### ▶️ 2025년도 - [예시 양식](template-study.md) --- ## ✏️ 스터디 작성 가이드 새로운 스터디를 추가하려면 `/docs//연/월/일` 폴더 안에 다음 양식을 복사해 새로운 `.md` 파일로 작성하면 됩니다 👇 - 파일명 형식: `title.md` (예: `nestjs-di-study.md`) - 포맷: [공통 스터디 템플릿](template-study.md) > 💡 파일명에 날짜를 포함하면 Jekyll이 자동으로 날짜를 인식합니다. > 💡 카테고리별 메뉴에서 자동으로 분류되어 표시됩니다. ",
    "url": "/",
    
    "relUrl": "/"
  }
}
